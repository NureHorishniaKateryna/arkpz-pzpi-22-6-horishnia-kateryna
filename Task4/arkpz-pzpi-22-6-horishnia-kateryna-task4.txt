Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук


Кафедра програмної інженерії



ЗВІТ
до лабораторної роботи №4
з дисципліни «Аналіз та рефакторинг коду»


Виконала:
ст. гр. ПЗПІ-22-6,
Горішня Катерина Олексіївна


Перевірив:
ст. викладач каф. ПІ,
Сокорчук Ігор Петрович




Харків 2024

1 РОЗРОБКА IoT КЛІЄНТА (БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)

1.1 Мета роботи
Метою роботи є розробка IoT клієнта (бізнес-логіки та функцій налаштування).

1.2 Хід роботи
1.2.1	Розробити будову програмного забезпечення ІоТ клієнта.
IoT-клієнт буде розроблений як частина програмної системи для інтелектуального освітлення, використовуючи мову програмування C++. Програмне забезпечення клієнта використовуватиме бібліотеки curl для виконання HTTP-запитів і Paho MQTT для взаємодії з сервером через протокол MQTT. Основним завданням IoT-клієнта є збирання даних від сенсорів руху, передача цих даних на сервер для подальшого аналізу та керування освітленням. Клієнт буде відправляти зібрані дані у форматі JSON через MQTT і отримувати команди від сервера для включення або вимкнення освітлення залежно від умов, що були виявлені за допомогою сенсорів. Ця система забезпечить автоматизацію управління освітленням на основі реальних даних з сенсорів і дозволить здійснювати моніторинг і керування освітленням віддалено.

1.2.2	Створити UML діаграму прецедентів для ІоТ клієнта.
Створимо UML діаграму прецедентів для IoT клієнта (рис. 1):
 

Рисунок 1 - UML діаграма прецедентів для IoT клієнта

1.2.3	Розробити бізнес логіку (математину обробку повʼязаних із предметною областю даних) та функції налаштування ІоТ клієнта.
У цьому розділі описано бізнес-логіку, яку ми розробляли для нашої системи інтелектуального освітлення. Бізнес-логіка відповідає за автоматичне керування станом освітлення, зокрема на основі сенсорів руху, ручного керування та розкладу роботи пристроїв. Основна функція deviceLoop() забезпечує безперервну перевірку умов для включення або вимкнення освітлення.
Функція працює в циклі, де першочергово враховуються тригери (наприклад, спрацьовування сенсора руху), що активують освітлення на певний час. Після цього система перевіряє час і розклад для коригування стану пристрою. Якщо тригер втратив свою дію, керування пристроєм здійснюється вручну або згідно з розкладом. Всі зміни стану пристрою синхронізуються з іншими компонентами системи, що дозволяє підтримувати актуальність даних у реальному часі.
 1   void deviceLoop() {
 2       int64_t trigger_expires_at = 0;
 3   
 4       while(true) {
 5           bool enabled = false;
 6   
 7           if(triggered.load()) {
 8               enabled = true;
 9               trigger_expires_at = time(nullptr) + TRIGGER_TIMEOUT;
10               triggered.store(false);
11           }
12           if(time(nullptr) <= trigger_expires_at) {
13               enabled = true;
14           } else {
15               enabled = manual_state.load();
16           }
17   
18           std::time_t t = std::time(nullptr);
19           const std::tm* now = std::localtime(&t);
20           enabled = enabled || schedule[now->tm_hour];
21   
22           if(current_state != enabled) {
23               std::cout << "New state: " << enabled << std::endl;
24               current_state.store(enabled);
25               cv.notify_all();
26           }
27       }
28   }

Функції налаштування IoT клієнта були розроблені таким чином, щоб забезпечити зручне і ефективне управління освітленням через інтеграцію з сервером та можливість отримання і обробки даних у реальному часі. Для цього були створені функції, що дозволяють клієнту взаємодіяти з сервером через HTTP-запити та MQTT-протокол. Зокрема, функція fetchSchedule() відповідає за отримання та оновлення розкладу роботи освітлення, завдяки чому клієнт може коригувати час включення та вимкнення освітлення згідно з розкладом, що надходить з сервера.
 1   void fetchSchedule() {
 2       std::string sched_str = curlRequest("/device/schedule");
 3       nlohmann::json sched;
 4   
 5       try {
 6           sched = nlohmann::json::parse(sched_str);
 7           std::cout << "Schedule fetched from server" << std::endl;
 8       } catch (const nlohmann::json::parse_error& e) {
 9           std::cerr << "Failed to parse schedule: " << e.what() << std::endl;
10       }
11   
12       resetSchedule();
13   
14       for(auto sched_item : sched) {
15           int32_t start_hour;
16           int32_t end_hour;
17   
18           try {
19               start_hour = sched_item["start_hour"].get<int32_t>();
20               end_hour = sched_item["end_hour"].get<int32_t>();
21           } catch (const nlohmann::json::type_error& e) {
22               continue;
23           }
24   
25           if(start_hour < 0 || start_hour > 23 || end_hour < 0 || end_hour > 23 || start_hour > end_hour) {
26               continue;
27           }
28   
29           for(int32_t i = start_hour; i <= end_hour; i++) {
30               schedule[i] = true;

Друга функція, client.set_message_callback(), є обробником повідомлень, що надходять через MQTT. Вона налаштовує зворотний виклик, який реагує на різні теми повідомлень, що отримуються від сервера. Якщо повідомлення стосується конфігурації пристрою (тобто тема повідомлення починається з config/), то обробник намагається розпарсити отриману конфігурацію, наприклад, для налаштування ручного керування освітленням. Якщо ж тема повідомлення починається з schedule/, це означає, що сервер відправив запит на оновлення розкладу роботи пристрою, і в такому випадку викликається функція fetchSchedule(), щоб оновити локальний розклад на клієнті.
 1   client.set_message_callback([](const mqtt::const_message_ptr& 
    msg) {
 2       if(msg->get_topic().starts_with("config/")) {
 3           std::cout << "Got config update from server: " << msg->get_payload_str() << std::endl;
 4   
 5           try {
 6               auto jsonConfig = nlohmann::json::parse(msg-
    >get_payload_str());
 7               manual_state.store(jsonConfig["enabled_manually"].get<bool>());
 8           } catch (const nlohmann::json::parse_error& e) {
 9               std::cerr << "Failed to parse config: " << e.what() << std::endl;
10           }
11       } else if(msg->get_topic().starts_with("schedule/")) {
12           std::cout << "Got schedule update request from server: " << msg->get_payload_str() << std::endl;
13           fetchSchedule();
14       }
15   });

Наступна частина, що належить до цієї функції, включає в себе обробку отриманих даних через MQTT. Якщо надійшло повідомлення, яке містить оновлення для розкладу або конфігурації, система зчитує ці дані, перевіряє їх на правильність і, в разі потреби, змінює налаштування або розклад роботи пристрою. Вона також дозволяє підтримувати актуальність розкладу та налаштувань пристрою, забезпечуючи синхронізацію між сервером та клієнтом у реальному часі.
 1   std::cout << "Fetching configuration..." << std::endl;
 2   std::string config = curlRequest("/device/config");
 3   
 4   try {
 5       auto jsonConfig = nlohmann::json::parse(config);
 6       std::cout << "Configuration fetched: " << jsonConfig.dump(4) << std::endl;
 7  manual_state.store(jsonConfig["enabled_manually"].get<bool>());
 8   } catch (const nlohmann::json::parse_error& e) {
 9       std::cerr << "Failed to parse configuration: " << e.what() << std::endl;
10       return 1;
11   }
 
1.2.4	Створити діаграму діяльності для ІоТ клієнта.
Створимо діаграму діяльності для IoT клієнта (рис. 2):
 
Рисунок 2 – Діаграма діяльності для IoT клієнта

1.2.5	Створити програмну реалізацію бізнес логіки та функцій налаштування ІоТ клієнта.
Створено програмну реалізацію бізнес-логіки та функцій налаштування ІоТ клієнта для системи інтелектуального освітлення з датчикми руху. Бізнес-логіка системи забезпечує автоматичне керування освітленням у приміщеннях на основі даних, отриманих від датчиків руху. Коли датчик фіксує рух, система автоматично вмикає освітлення, а після визначеного часу без руху вимикає. Система також враховує час доби для коригування яскравості освітлення, що дозволяє знижувати енергоспоживання. 
Для забезпечення стабільної роботи системи використано протоколи зв'язку, такі як MQTT та HTTP. Для гарантування безпеки даних реалізовано шифрування передавання інформації між пристроями, а також систему аутентифікації користувачів для доступу до налаштувань.

1.2.6	Перевірити роботу ІоТ клієнта.
Протестуємо роботу IoT клієнта. 
На рисунку 3 показано виведення командного рядка, де клієнт отримує конфігурацію з сервера, включаючи налаштування ціни на електрику та параметрів автоматичного керування. Також клієнт підключається до сервера MQTT, що підтверджується відповідними повідомленнями в консолі.

Рисунок 3 – Успішна ініціалізація ІоТ клієнта

На рисунку 4 показано виведення командного рядка, де клієнт отримує оновлену конфігурацію від сервера, зокрема зміни в налаштуваннях автоматичного та ручного управління. Після отримання даних клієнт відправляє оновлений стан на сервер, де відображається новий стан і параметри, такі як ціна на електрику та режим керування.

Рисунок 4  - Запит на автоматичну відправку даних сенсора на сервер

На рисунку 5 показано виведення командного рядка, де після активації датчику (новий стан: 1) відправляється повідомлення про увімкнення пристрою. Через певний час (10 секунд) стан змінюється на 0, і система відправляє повідомлення про вимкнення пристрою, що підтверджує автоматичне керування пристроєм.

Рисунок 5  - Автоматичне вимкнення датчику через 10 секунд

1.3 Висновки
У ході виконання лабораторної роботи було розроблено IoT-клієнт для системи інтелектуального освітлення з датчиками руху. Реалізовано обробку даних від сенсорів руху, а також алгоритми для автоматичного керування освітленням залежно від наявності руху в приміщенні. Забезпечено підтримку динамічного налаштування розкладу роботи освітлення та коригування його параметрів, таких як яскравість, залежно від часу доби. Система автоматично вимикає освітлення через визначений час після виявлення руху, що дозволяє знижувати енергоспоживання.
Робота системи була успішно перевірена під час тестування, що підтвердило коректність виконання основних функцій, таких як отримання конфігурацій та налаштувань, автоматичне керування освітленням і коригування його параметрів згідно з розкладом.

1.4 Список використаних джерел 
1. Creately – офіційний сайт. URL: https://app.creately.com/ (дата звернення: 25.12.2024).
2. Swagger – офіційний сайт. URL: https://swagger.io/ (дата звернення: 25.12.2024).
3. CLion – офіційний сайт. URL: https://www.jetbrains.com/clion/ (дата звернення: 25.12.2024).
4. MQTT Protocol – офіційна документація. URL: https://mqtt.org (дата звернення: 25.12.2024).

1.5 Посилання
Посилання на GitHub репозиторій: 
https://github.com/NureHorishniaKateryna/arkpz-pzpi-22-6-horishnia-kateryna/tree/main/Task2
Посилання на відео доповіді: https://youtu.be/
